<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Mini OpenSCAD JS</title>
  <style>
    body { margin: 0; overflow: hidden; display: flex; flex-direction: row; height: 100vh; }
    #editor { width: 40%; height: 100vh; background: #111; color: #0f0; font-family: monospace; padding: 10px; overflow: auto; }
    #preview { width: 60%; height: 100vh; background: #222; }
    #controls { position: absolute; top: 10px; right: 10px; z-index: 10; }
    button { margin: 5px; padding: 8px 12px; }
  </style>
</head>
<body>

<div id="editor" contenteditable="true">
// Write OpenSCAD here!

cube([10, 10, 10]);
translate([15,0,0]) sphere(5);
</div>

<div id="preview"></div>

<div id="controls">
  <button onclick="runCode()">Render</button>
  <button onclick="exportSTL()">Export STL</button>
</div>

<!-- âœ… load Three.js and addons directly -->
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/exporters/STLExporter.js"></script>

<script>
let scene, camera, renderer, controls;

function init() {
  scene = new THREE.Scene();
  camera = new THREE.PerspectiveCamera(75, window.innerWidth * 0.6 / window.innerHeight, 0.1, 1000);
  camera.position.set(30, 30, 30);
  renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth * 0.6, window.innerHeight);
  document.getElementById('preview').appendChild(renderer.domElement);
  controls = new THREE.OrbitControls(camera, renderer.domElement);

  animate();
}

function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}

function runCode() {
  const code = document.getElementById('editor').innerText;
  scene.clear();

  try {
    parseCode(code);
  } catch (e) {
    console.error(e);
    alert("Error in parsing!\n" + e.message);
  }
}

function parseCode(code) {
  const lines = code.split(';');
  for (let line of lines) {
    line = line.trim();
    if (line.startsWith('cube')) {
      const match = /\[(.*?)\]/.exec(line);
      if (match) {
        const sizes = match[1].split(',').map(Number);
        const geom = new THREE.BoxGeometry(sizes[0], sizes[1], sizes[2]);
        const mat = new THREE.MeshNormalMaterial();
        const mesh = new THREE.Mesh(geom, mat);
        scene.add(mesh);
      }
    }
    if (line.startsWith('sphere')) {
      const match = /\((.*?)\)/.exec(line);
      if (match) {
        const radius = parseFloat(match[1]);
        const geom = new THREE.SphereGeometry(radius, 32, 32);
        const mat = new THREE.MeshNormalMaterial();
        const mesh = new THREE.Mesh(geom, mat);
        scene.add(mesh);
      }
    }
    if (line.startsWith('translate')) {
      const match = /\[(.*?)\]\s*(.*)/.exec(line);
      if (match) {
        const pos = match[1].split(',').map(Number);
        const subcode = match[2];
        if (subcode.startsWith('sphere')) {
          const radMatch = /\((.*?)\)/.exec(subcode);
          const radius = parseFloat(radMatch[1]);
          const geom = new THREE.SphereGeometry(radius, 32, 32);
          const mat = new THREE.MeshNormalMaterial();
          const mesh = new THREE.Mesh(geom, mat);
          mesh.position.set(pos[0], pos[1], pos[2]);
          scene.add(mesh);
        }
      }
    }
  }
}

function exportSTL() {
  const exporter = new THREE.STLExporter();
  const result = exporter.parse(scene);
  const blob = new Blob([result], { type: 'text/plain' });
  const link = document.createElement('a');
  link.href = URL.createObjectURL(blob);
  link.download = 'model.stl';
  link.click();
}

init();
</script>

</body>
</html>
