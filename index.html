<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Simple pyScad Clone</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: sans-serif; }
    #ui {
      position: absolute; top: 10px; left: 10px; background: rgba(255,255,255,0.8);
      padding: 10px; border-radius: 8px;
    }
    textarea {
      width: 400px;
      height: 300px;
      resize: none;
    }
    button { margin-top: 10px; padding: 5px 10px; }
  </style>
</head>
<body>
  <div id="ui">
    <textarea id="code">// Example
cylinder(10, 5, 5);
rotate([45,0,0])
cylinder(5,2,2);
    </textarea><br>
    <button onclick="runCode()">Run</button>
    <button onclick="exportSTL()">Export STL</button>
  </div>
  
  <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r149/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r149/examples/js/exporters/STLExporter.js"></script>

  <script>
    let scene, camera, renderer, controls;
    let objects = [];

    function init() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf0f0f0);

      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.set(30, 30, 30);

      renderer = new THREE.WebGLRenderer({antialias: true});
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      window.addEventListener('resize', onWindowResize, false);

      animate();
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // âœ¨ Simple Orbit-like control
    let isMouseDown = false;
    let mouse = { x: 0, y: 0 };
    let targetRotation = { x: 0, y: 0 };

    window.addEventListener('mousedown', function(event) {
      isMouseDown = true;
      mouse.x = event.clientX;
      mouse.y = event.clientY;
    });

    window.addEventListener('mousemove', function(event) {
      if (isMouseDown) {
        targetRotation.y += (event.clientX - mouse.x) * 0.005;
        targetRotation.x += (event.clientY - mouse.y) * 0.005;
        mouse.x = event.clientX;
        mouse.y = event.clientY;
      }
    });

    window.addEventListener('mouseup', function() {
      isMouseDown = false;
    });

    function animate() {
      requestAnimationFrame(animate);

      // Rotate camera around scene center
      let radius = 50;
      camera.position.x = radius * Math.sin(targetRotation.y) * Math.cos(targetRotation.x);
      camera.position.y = radius * Math.sin(targetRotation.x);
      camera.position.z = radius * Math.cos(targetRotation.y) * Math.cos(targetRotation.x);
      camera.lookAt(0,0,0);

      renderer.render(scene, camera);
    }

    function clearScene() {
      objects.forEach(obj => scene.remove(obj));
      objects = [];
    }

    function runCode() {
      clearScene();
      let code = document.getElementById('code').value;

      const lines = code.split('\n');
      lines.forEach(line => {
        line = line.trim();
        if (line.startsWith('cylinder(')) {
          const params = line.slice(9, -1).split(',').map(Number);
          const height = params[0];
          const radiusTop = params[1];
          const radiusBottom = params[2];
          const geometry = new THREE.CylinderGeometry(radiusTop, radiusBottom, height, 32);
          const material = new THREE.MeshNormalMaterial();
          const cylinder = new THREE.Mesh(geometry, material);
          scene.add(cylinder);
          objects.push(cylinder);
        }
        if (line.startsWith('rotate(')) {
          const params = JSON.parse(line.slice(7).replace(')',''));
          const lastObject = objects[objects.length-1];
          if (lastObject) {
            lastObject.rotation.x = params[0] * Math.PI/180;
            lastObject.rotation.y = params[1] * Math.PI/180;
            lastObject.rotation.z = params[2] * Math.PI/180;
          }
        }
      });
    }

    function exportSTL() {
      const exporter = new THREE.STLExporter();
      const result = exporter.parse(scene);
      const blob = new Blob([result], {type: 'text/plain'});
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = 'scene.stl';
      link.click();
    }

    init();
  </script>
</body>
</html>
