<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Mini OpenSCAD Clone</title>
  <style>
    body {
      margin: 0;
      display: flex;
      height: 100vh;
      overflow: hidden;
      font-family: sans-serif;
    }
    #editor {
      width: 40%;
      height: 100%;
      border-right: 2px solid #ddd;
      padding: 10px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
    }
    #code {
      flex: 1;
      width: 100%;
      font-family: monospace;
      font-size: 14px;
      padding: 10px;
      box-sizing: border-box;
    }
    #run {
      margin-top: 10px;
      padding: 10px;
      background: #4CAF50;
      color: white;
      border: none;
      cursor: pointer;
      font-size: 16px;
    }
    #viewport {
      flex: 1;
      background: #111;
    }
  </style>
</head>
<body>

<div id="editor">
  <textarea id="code" placeholder="Write OpenSCAD code here..."></textarea>
  <button id="run">Render</button>
</div>
<div id="viewport"></div>

<!-- Three.js (from official CDN as module) -->
<script type="module">

import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js';

// --- Tokenizer ---
function tokenize(input) {
  const tokens = [];
  const regex = /\s*(=>|{|}|\(|\)|\[|\]|,|;|:=|=|\+|-|\*|\/|[A-Za-z_][A-Za-z0-9_]*|\d+\.?\d*|"[^"]*")\s*/g;
  let match;
  while (match = regex.exec(input)) {
    tokens.push(match[1]);
  }
  return tokens;
}

// --- Parser ---
function parse(tokens) {
  let pos = 0;

  function parseExpression() {
    let token = tokens[pos++];
    if (!isNaN(parseFloat(token))) {
      return { type: 'number', value: parseFloat(token) };
    } else if (token.match(/^[A-Za-z_][A-Za-z0-9_]*$/)) {
      return { type: 'identifier', name: token };
    }
  }

  function parseArguments() {
    let args = [];
    if (tokens[pos] === '(') {
      pos++; // skip (
      while (tokens[pos] !== ')') {
        args.push(parseExpression());
        if (tokens[pos] === ',') pos++;
      }
      pos++; // skip )
    }
    return args;
  }

  function parseCommand() {
    let name = tokens[pos++];
    let args = parseArguments();
    let children = [];

    if (tokens[pos] === '{') {
      pos++; // skip {
      while (tokens[pos] !== '}') {
        children.push(parseCommand());
      }
      pos++; // skip }
    }

    return { type: 'command', name, args, children };
  }

  function parseProgram() {
    let commands = [];
    while (pos < tokens.length) {
      commands.push(parseCommand());
    }
    return commands;
  }

  return parseProgram();
}

// --- Scene Setup ---
let scene, camera, renderer;

function init() {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x222222);

  camera = new THREE.PerspectiveCamera(75, window.innerWidth * 0.6 / window.innerHeight, 0.1, 1000);
  camera.position.set(5,5,5);
  camera.lookAt(0,0,0);

  renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth * 0.6, window.innerHeight);
  document.getElementById('viewport').appendChild(renderer.domElement);

  animate();
}

function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}

// --- Render Parsed Program ---
function renderProgram(program) {
  // Clear previous scene
  while(scene.children.length > 0){ 
    scene.remove(scene.children[0]); 
  }

  program.forEach(cmd => renderCommand(cmd));
}

function renderCommand(cmd) {
  if (cmd.name === 'cube') {
    let size = cmd.args[0]?.value || 1;
    const geometry = new THREE.BoxGeometry(size, size, size);
    const material = new THREE.MeshNormalMaterial();
    const cube = new THREE.Mesh(geometry, material);
    scene.add(cube);
  }
  else if (cmd.name === 'sphere') {
    let r = cmd.args[0]?.value || 1;
    const geometry = new THREE.SphereGeometry(r, 32, 32);
    const material = new THREE.MeshNormalMaterial();
    const sphere = new THREE.Mesh(geometry, material);
    scene.add(sphere);
  }
  else if (cmd.name === 'cylinder') {
    let h = cmd.args[0]?.value || 1;
    let r = cmd.args[1]?.value || 0.5;
    const geometry = new THREE.CylinderGeometry(r, r, h, 32);
    const material = new THREE.MeshNormalMaterial();
    const cylinder = new THREE.Mesh(geometry, material);
    scene.add(cylinder);
  }
  // TODO: implement translate, rotate, scale, color, union, difference, etc.

  cmd.children.forEach(child => renderCommand(child));
}

// --- Run Button ---
document.getElementById('run').onclick = function() {
  const code = document.getElementById('code').value;
  const tokens = tokenize(code);
  const program = parse(tokens);
  console.log(program); // Debug
  renderProgram(program);
};

// --- Init scene ---
init();

</script>

</body>
</html>
